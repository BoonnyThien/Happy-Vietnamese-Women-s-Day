/**
 * name: @tresjs/post-processing
 * version: v0.7.1
 * (c) 2024
 * description: Post-processing library for TresJS
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
import { inject as Y, shallowRef as C, watchEffect as w, onUnmounted as N, watch as g, defineComponent as d, provide as V, computed as L, renderSlot as U } from "vue";
import { EffectPass as q, BloomEffect as F, DepthOfFieldEffect as P, EffectComposer as R, RenderPass as H, NormalPass as I, DepthDownsamplingPass as K, GlitchEffect as b, GlitchMode as J, OutlineEffect as O, PixelationEffect as D, VignetteTechnique as Q, BlendFunction as $, VignetteEffect as T, NoiseEffect as z } from "postprocessing";
import { useTresContext as h, useRenderLoop as Z, normalizeColor as S } from "@tresjs/core";
import { HalfFloatType as k } from "three";
const G = Symbol(), m = (l) => {
  const t = Y(G), e = C(null), n = C(null), { scene: o, camera: a } = h();
  w(() => {
    !a.value || !(n != null && n.value) || (n.value.mainCamera = a.value);
  });
  let s = () => {
  };
  return s = w(() => {
    !a.value || !(t != null && t.value) || !o.value || (s(), !n.value && (n.value = l(), e.value = new q(a.value, n.value), t.value.addPass(e.value)));
  }), N(() => {
    var r, i, c;
    e.value && ((r = t == null ? void 0 : t.value) == null || r.removePass(e.value)), (i = n.value) == null || i.dispose(), (c = e.value) == null || c.dispose();
  }), {
    pass: e,
    effect: n
  };
}, W = /([^[.\]])+/g, ee = (l, t) => {
  if (!t)
    return;
  const e = Array.isArray(t) ? t : t.match(W);
  return e == null ? void 0 : e.reduce((n, o) => n && n[o], l);
}, A = (l, t, e) => {
  const n = Array.isArray(t) ? t : t.match(W);
  n && n.reduce((o, a, s) => (o[a] === void 0 && (o[a] = {}), s === n.length - 1 && (o[a] = e), o[a]), l);
}, E = (l, t) => {
  const e = { ...l };
  return t.forEach((n) => delete e[n]), e;
}, j = (l, t, e, n, o = {}) => g(
  l,
  (a) => {
    var s;
    if (t.value)
      if (a === void 0) {
        const r = n();
        A(t.value, e, ee(r, e)), (s = r.dispose) == null || s.call(r);
      } else
        A(t.value, e, l());
  },
  o
), x = (l, t, e) => l.map(([n, o]) => j(
  n,
  t,
  o,
  e
)), _ = (l, t, e) => Object.keys(l).map((n) => j(
  () => l[n],
  t,
  n,
  e
)), ae = /* @__PURE__ */ d({
  __name: "Bloom",
  props: {
    blendFunction: {},
    intensity: {},
    kernelSize: {},
    luminanceThreshold: {},
    luminanceSmoothing: {},
    mipmapBlur: { type: Boolean, default: void 0 }
  },
  setup(l, { expose: t }) {
    const e = l, { pass: n, effect: o } = m(() => new F(e));
    return t({ pass: n, effect: o }), x(
      [
        // blendFunction is not updated, because it has no setter in BloomEffect
        [() => e.intensity, "intensity"],
        [() => e.kernelSize, "kernelSize"],
        [() => e.luminanceSmoothing, "luminanceMaterial.smoothing"],
        [() => e.luminanceThreshold, "luminanceMaterial.threshold"]
      ],
      o,
      () => new F()
    ), (a, s) => null;
  }
}), se = /* @__PURE__ */ d({
  __name: "DepthOfField",
  props: {
    blendFunction: {},
    worldFocusDistance: {},
    worldFocusRange: {},
    focusDistance: {},
    focusRange: {},
    bokehScale: {},
    resolutionScale: {},
    resolutionX: {},
    resolutionY: {}
  },
  setup(l, { expose: t }) {
    const e = l, { camera: n } = h(), { pass: o, effect: a } = m(() => new P(n.value, e));
    return t({ pass: o, effect: a }), x(
      [
        // blendFunction is not updated, because it has no setter in BloomEffect
        [() => e.worldFocusDistance, "circleOfConfusionMaterial.worldFocusDistance"],
        [() => e.focusDistance, "circleOfConfusionMaterial.focusDistance"],
        [() => e.worldFocusRange, "circleOfConfusionMaterial.worldFocusRange"],
        [() => e.focusRange, "circleOfConfusionMaterial.focusRange"],
        [() => e.bokehScale, "bokehScale"],
        [() => e.resolutionScale, "blurPass.resolution.scale"],
        [() => e.resolutionX, "resolution.width"],
        [() => e.resolutionY, "resolution.height"]
      ],
      a,
      () => new P()
    ), (s, r) => null;
  }
});
let v;
function M() {
  var l;
  if (v !== void 0)
    return v;
  try {
    let t;
    const e = document.createElement("canvas");
    return v = !!(window.WebGL2RenderingContext && (t = e.getContext("webgl2"))), t && ((l = t.getExtension("WEBGL_lose_context")) == null || l.loseContext()), v;
  } catch {
    return v = !1;
  }
}
const re = /* @__PURE__ */ d({
  __name: "EffectComposer",
  props: {
    enabled: { type: Boolean, default: !0 },
    children: {},
    depthBuffer: { type: Boolean, default: void 0 },
    disableNormalPass: { type: Boolean, default: !1 },
    stencilBuffer: { type: Boolean, default: void 0 },
    resolutionScale: {},
    autoClear: { type: Boolean, default: !0 },
    multisampling: { default: 0 },
    frameBufferType: { default: k }
  },
  setup(l, { expose: t }) {
    const e = l, { scene: n, camera: o, renderer: a, sizes: s } = h(), r = C(null);
    let i = null, c = null;
    V(G, r), t({ composer: r });
    const f = () => {
      r.value && (c = new I(n.value, o.value), c.enabled = !1, r.value.addPass(c), e.resolutionScale !== void 0 && M() && (i = new K({
        normalBuffer: c.texture,
        resolutionScale: e.resolutionScale
      }), i.enabled = !1, r.value.addPass(i)));
    }, B = L(() => {
      const u = new R(), p = {
        depthBuffer: e.depthBuffer !== void 0 ? e.depthBuffer : u.inputBuffer.depthBuffer,
        stencilBuffer: e.stencilBuffer !== void 0 ? e.stencilBuffer : u.inputBuffer.stencilBuffer,
        multisampling: M() ? e.multisampling !== void 0 ? e.multisampling : u.multisampling : 0,
        frameBufferType: e.frameBufferType !== void 0 ? e.frameBufferType : k
      };
      return u.dispose(), p;
    }), y = () => {
      !a.value && !n.value && !o.value || (r.value = new R(a.value, B.value), r.value.addPass(new H(n.value, o.value)), e.disableNormalPass || f());
    };
    g([a, n, o, () => e.disableNormalPass], () => {
      !s.width.value || !s.height.value || y();
    }), g(() => [s.width.value, s.height.value], ([u, p]) => {
      !u && !p || (r.value ? r.value.setSize(u, p) : y());
    }, {
      immediate: !0
    });
    const { onLoop: X } = Z();
    return X(({ delta: u }) => {
      if (e.enabled && a.value && r.value && s.width.value && s.height.value) {
        const p = a.value.autoClear;
        a.value.autoClear = e.autoClear, e.stencilBuffer && !e.autoClear && a.value.clearStencil(), r.value.render(u), a.value.autoClear = p;
      }
    }), N(() => {
      var u;
      (u = r.value) == null || u.dispose();
    }), (u, p) => U(u.$slots, "default");
  }
}), ue = /* @__PURE__ */ d({
  __name: "Glitch",
  props: {
    blendFunction: {},
    delay: {},
    duration: {},
    strength: {},
    mode: {},
    active: { type: Boolean },
    ratio: {},
    columns: {},
    chromaticAberrationOffset: {},
    perturbationMap: {},
    dtSize: {}
  },
  setup(l, { expose: t }) {
    const e = l, { pass: n, effect: o } = m(() => new b(e));
    return t({ pass: n, effect: o }), w(() => {
      const a = () => {
        if (e.mode !== void 0)
          return e.active === !1 ? J.DISABLED : e.mode;
        const s = new b(), r = s.mode;
        return s.dispose(), r;
      };
      o.value && (o.value.mode = a());
    }), _(
      E(e, ["active", "mode", "blendFunction"]),
      o,
      () => new b()
    ), (a, s) => null;
  }
}), ie = /* @__PURE__ */ d({
  __name: "Outline",
  props: {
    outlinedObjects: {},
    blur: { type: Boolean, default: void 0 },
    xRay: { type: Boolean, default: void 0 },
    kernelSize: {},
    pulseSpeed: {},
    resolutionX: {},
    resolutionY: {},
    edgeStrength: {},
    patternScale: {},
    multisampling: {},
    blendFunction: {},
    patternTexture: {},
    resolutionScale: {},
    hiddenEdgeColor: {},
    visibleEdgeColor: {}
  },
  setup(l, { expose: t }) {
    const e = l, n = (f) => f !== void 0 ? S(f).getHex() : void 0, { camera: o, scene: a } = h(), s = {
      blur: e.blur,
      xRay: e.xRay,
      kernelSize: e.kernelSize,
      pulseSpeed: e.pulseSpeed,
      resolutionX: e.resolutionX,
      resolutionY: e.resolutionY,
      patternScale: e.patternScale,
      edgeStrength: e.edgeStrength,
      blendFunction: e.blendFunction,
      multisampling: e.multisampling,
      patternTexture: e.patternTexture,
      resolutionScale: e.resolutionScale,
      hiddenEdgeColor: n(e.hiddenEdgeColor),
      visibleEdgeColor: n(e.visibleEdgeColor)
    }, { pass: r, effect: i } = m(() => new O(a.value, o.value, s));
    t({ pass: r, effect: i }), g(
      [() => e.outlinedObjects, i],
      // watchEffect is intentionally not used here as it would result in an endless loop
      () => {
        var f;
        (f = i.value) == null || f.selection.set(e.outlinedObjects || []);
      },
      {
        immediate: !0
      }
    );
    const c = L(() => ({
      hiddenEdgeColor: e.hiddenEdgeColor ? S(e.hiddenEdgeColor) : void 0,
      visibleEdgeColor: e.visibleEdgeColor ? S(e.visibleEdgeColor) : void 0
    }));
    return x(
      [
        /* some properties are not updated because of different reasons:
            resolutionX - has no setter in OutlineEffect
            resolutionY - has no setter in OutlineEffect
            blendFunction - has no setter in OutlineEffect
            patternTexture - different type in constructor and in setter
            resolutionScale - has no setter in OutlineEffect
          */
        [() => e.blur, "blur"],
        [() => e.xRay, "xRay"],
        [() => e.pulseSpeed, "pulseSpeed"],
        [() => e.kernelSize, "kernelSize"],
        [() => e.edgeStrength, "edgeStrength"],
        [() => e.patternScale, "patternScale"],
        [() => e.multisampling, "multisampling"],
        [() => c.value.hiddenEdgeColor, "hiddenEdgeColor"],
        [() => c.value.visibleEdgeColor, "visibleEdgeColor"]
      ],
      i,
      () => new O()
    ), (f, B) => null;
  }
}), ce = /* @__PURE__ */ d({
  __name: "Pixelation",
  props: {
    granularity: {}
  },
  setup(l, { expose: t }) {
    const e = l, { pass: n, effect: o } = m(() => new D(e.granularity));
    return t({ pass: n, effect: o }), _(
      e,
      o,
      () => new D()
    ), (a, s) => null;
  }
}), fe = /* @__PURE__ */ d({
  __name: "Vignette",
  props: {
    technique: { default: Q.DEFAULT },
    blendFunction: { default: $.NORMAL },
    offset: { default: 0.5 },
    darkness: { default: 0.5 }
  },
  setup(l, { expose: t }) {
    const e = l, { pass: n, effect: o } = m(() => new T(e));
    return t({ pass: n, effect: o }), _(
      E(e, ["blendFunction"]),
      o,
      () => new T()
    ), (a, s) => null;
  }
}), de = /* @__PURE__ */ d({
  __name: "Noise",
  props: {
    premultiply: { type: Boolean, default: !1 },
    blendFunction: { default: $.SCREEN }
  },
  setup(l, { expose: t }) {
    const e = l, { pass: n, effect: o } = m(() => new z(e));
    return t({ pass: n, effect: o }), _(
      E(e, ["blendFunction"]),
      o,
      () => new z()
    ), (a, s) => null;
  }
});
export {
  ae as Bloom,
  se as DepthOfField,
  re as EffectComposer,
  ue as Glitch,
  de as Noise,
  ie as Outline,
  ce as Pixelation,
  fe as Vignette
};
